<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1280, initial-scale=1">
    <title>Chess Master | Man Games</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #2c3e50;
            --board-border: #34495e;
            --light-square: #eeeed2;
            --dark-square: #769656;
            --highlight: rgba(255, 255, 0, 0.5);
            --possible-move: rgba(0, 0, 0, 0.2);
            --text-color: #ecf0f1;
            --accent: #f1c40f;
            --cursor-color: #e74c3c;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            overflow: hidden;
            /* Prevent scrolling */
        }

        h1 {
            font-family: 'Fredoka', sans-serif;
            margin-bottom: 20px;
            font-size: 2.5rem;
            color: var(--accent);
            text-shadow: 2px 2px 0 #000;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            filter: blur(5px);
            /* Initially blurred for modal */
            transition: filter 0.3s ease;
            outline: none;
            /* Remove focus outline */
        }

        .game-container.active {
            filter: none;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 10px 20px;
            border-radius: 10px;
            border: none;
            font-family: 'Fredoka', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s;
            background: var(--accent);
            color: #2c3e50;
            font-weight: bold;
        }

        button:hover,
        button:focus {
            transform: scale(1.05);
            outline: 3px solid var(--cursor-color);
        }

        .status {
            font-size: 1.2rem;
            font-weight: bold;
            min-height: 1.5em;
        }

        .chessboard {
            width: 480px;
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 10px solid var(--board-border);
            border-radius: 5px;
            background: var(--board-border);
        }

        .square {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3.5rem;
            /* Fixed font size */
            cursor: pointer;
            position: relative;
            overflow: hidden;
            /* Prevent fluctuation */
        }

        .square.light {
            background-color: var(--light-square);
        }

        .square.dark {
            background-color: var(--dark-square);
        }

        .square.selected {
            background-color: #bbcb2b !important;
        }

        .square.last-move {
            background-color: #f5f682 !important;
        }

        /* Keyboard Cursor */
        .square.cursor-active {
            box-shadow: inset 0 0 0 5px var(--cursor-color);
            z-index: 10;
        }

        /* Dot for possible moves */
        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            pointer-events: none;
        }

        /* Ring for possible capture */
        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 85%;
            height: 85%;
            border: 5px solid rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            background-color: transparent;
            pointer-events: none;
        }

        .piece {
            cursor: grab;
            z-index: 2;
            line-height: 1;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* Using filled unicode characters for both */
        }

        .piece.white {
            color: #fff;
            text-shadow: 0 0 2px #000, 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .piece.black {
            color: #000;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
        }

        .back-btn {
            margin-top: 20px;
            color: var(--text-color);
            text-decoration: none;
            font-weight: bold;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .back-btn:hover,
        .back-btn:focus {
            opacity: 1;
            outline: 2px solid var(--cursor-color);
            border-radius: 5px;
            padding: 5px;
        }

        /* Difficulty Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal {
            background: white;
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            max-width: 90%;
            width: 400px;
            border: 5px solid var(--accent);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal h2 {
            color: #2c3e50;
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            margin-bottom: 30px;
        }

        .difficulty-btn {
            display: block;
            width: 100%;
            margin-bottom: 15px;
            padding: 15px;
            font-size: 1.2rem;
            background: var(--bg-color);
            color: white;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .difficulty-btn:hover,
        .difficulty-btn:focus {
            background: var(--secondary);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            outline: 4px solid var(--cursor-color);
        }

        .difficulty-btn.easy {
            background: #2ecc71;
        }

        .difficulty-btn.medium {
            background: #f39c12;
        }

        .difficulty-btn.hard {
            background: #e74c3c;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @media (max-width: 600px) {
            .chessboard {
                width: 340px;
                height: 340px;
            }

            .square {
                font-size: 2.2rem;
            }
        }

        /* TV Mode */
        body.mode-tv {
            cursor: none;
        }
    </style>
</head>

<body>

    <h1>Chess Master</h1>

    <div class="game-container" id="gameContainer" tabindex="0">
        <div class="controls">
            <button onclick="showDifficultyModal()">Change Difficulty</button>
            <button onclick="resetGame()">Restart Game</button>
        </div>

        <div class="status" id="status">White's Turn</div>

        <div class="chessboard" id="board">
            <!-- Squares generated by JS -->
        </div>
    </div>

    <a href="index.html" class="back-btn">← Back to Menu</a>

    <!-- Difficulty Modal -->
    <div class="modal-overlay" id="difficultyModal">
        <div class="modal">
            <h2>Select Difficulty</h2>
            <button class="difficulty-btn easy" onclick="startGame('easy')">Easy</button>
            <button class="difficulty-btn medium" onclick="startGame('medium')">Medium</button>
            <button class="difficulty-btn hard" onclick="startGame('hard')">Hard</button>
        </div>
    </div>

    <script>
        const boardElement = document.getElementById('board');
        const statusElement = document.getElementById('status');
        const modalElement = document.getElementById('difficultyModal');
        const gameContainer = document.getElementById('gameContainer');

        // Game State
        let board = [];
        let turn = 'white'; // 'white' or 'black'
        let selectedSquare = null;
        let possibleMoves = [];
        let gameActive = false;
        let currentDifficulty = 'medium';
        let castlingRights = { white: { k: true, q: true }, black: { k: true, q: true } };
        let enPassantTarget = null;
        let kingPositions = { white: [7, 4], black: [0, 4] };

        // Navigation State
        let cursor = [6, 4]; // Start at white king/pawn area
        let cursorHoldInterval = null;
        let lastMove = null;

        // Unicode Pieces (Using FILLED pieces for BOTH to get solid look)
        const PIECES = {
            k: '♚', q: '♛', r: '♜', b: '♝', n: '♞', p: '♟'
        };

        function showDifficultyModal() {
            modalElement.style.display = 'flex';
            gameContainer.classList.remove('active');
            gameActive = false;

            // Focus first button
            setTimeout(() => {
                const firstBtn = modalElement.querySelector('.difficulty-btn');
                if (firstBtn) firstBtn.focus();
            }, 100);
        }

        function startGame(difficulty) {
            currentDifficulty = difficulty;
            modalElement.style.display = 'none';
            gameContainer.classList.add('active');
            initBoard();
            gameContainer.focus();
        }

        function resetGame() {
            showDifficultyModal();
        }

        // Initialize Board
        function initBoard() {
            board = Array(8).fill(null).map(() => Array(8).fill(null));

            const setupRow = (row, color, pieces) => {
                pieces.forEach((p, col) => {
                    board[row][col] = { type: p, color: color };
                });
            };

            const backRow = ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'];
            const pawnRow = Array(8).fill('p');

            setupRow(0, 'black', backRow);
            setupRow(1, 'black', pawnRow);
            setupRow(6, 'white', pawnRow);
            setupRow(7, 'white', backRow);

            kingPositions = { white: [7, 4], black: [0, 4] };
            castlingRights = { white: { k: true, q: true }, black: { k: true, q: true } };
            enPassantTarget = null;
            turn = 'white';
            gameActive = true;
            statusElement.textContent = "White's Turn";
            selectedSquare = null;
            possibleMoves = [];
            cursor = [6, 4]; // Reset cursor
            lastMove = null;

            renderBoard();
        }

        function renderBoard() {
            boardElement.innerHTML = '';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = r;
                    square.dataset.col = c;

                    // Add piece
                    const piece = board[r][c];
                    if (piece) {
                        const pieceSpan = document.createElement('span');
                        pieceSpan.className = `piece ${piece.color}`;
                        pieceSpan.textContent = PIECES[piece.type];
                        square.appendChild(pieceSpan);
                    }

                    // Highlight selected
                    if (selectedSquare && selectedSquare[0] === r && selectedSquare[1] === c) {
                        square.classList.add('selected');
                    }

                    // Highlight Last Move
                    if (lastMove && ((lastMove.from[0] === r && lastMove.from[1] === c) ||
                        (lastMove.to[0] === r && lastMove.to[1] === c))) {
                        square.classList.add('last-move');
                    }

                    // Highlight possible moves
                    const move = possibleMoves.find(m => m.to[0] === r && m.to[1] === c);
                    if (move) {
                        if (piece) {
                            square.classList.add('possible-capture');
                        } else {
                            square.classList.add('possible-move');
                        }
                    }

                    // Highlight Cursor
                    if (gameActive && cursor[0] === r && cursor[1] === c) {
                        square.classList.add('cursor-active');
                    }

                    square.addEventListener('click', () => {
                        cursor = [r, c]; // Update cursor on click too
                        handleSquareClick(r, c);
                    });
                    boardElement.appendChild(square);
                }
            }
        }

        // --- Sound Manager (Synthesized) ---
        const SoundManager = {
            ctx: null,
            init: function () {
                try {
                    if (!this.ctx) {
                        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    }
                } catch (e) {
                    console.error("AudioContext init failed", e);
                }
            },
            playTone: function (freq, type, duration, vol = 0.1) {
                try {
                    if (!this.ctx) this.init();
                    if (!this.ctx) return;
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                    osc.connect(gain);
                    gain.connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch (e) {
                    console.error("playTone failed", e);
                }
            },
            move: function () {
                this.playTone(300, 'sine', 0.1, 0.1);
            },
            capture: function () {
                this.playTone(150, 'triangle', 0.15, 0.2);
                setTimeout(() => this.playTone(100, 'triangle', 0.2, 0.2), 50);
            },
            select: function () {
                this.playTone(600, 'sine', 0.05, 0.05);
            },
            gameOver: function () {
                this.playTone(400, 'sine', 0.2, 0.2);
                setTimeout(() => this.playTone(300, 'sine', 0.2, 0.2), 200);
                setTimeout(() => this.playTone(200, 'sine', 0.4, 0.2), 400);
            }
        };

        function handleSquareClick(r, c) {
            try {
                if (!gameActive) return;
                if (turn === 'black') return; // Player is always white

                const clickedPiece = board[r][c];

                // If selecting a piece of own color
                if (clickedPiece && clickedPiece.color === turn) {
                    SoundManager.select();
                    selectedSquare = [r, c];
                    possibleMoves = getValidMoves(board, turn).filter(m => m.from[0] === r && m.from[1] === c);
                    renderBoard();
                    return;
                }

                // If moving to a valid square
                if (selectedSquare) {
                    const move = possibleMoves.find(m => m.to[0] === r && m.to[1] === c);
                    if (move) {
                        makeMove(move);
                        renderBoard();

                        if (gameActive) {
                            setTimeout(aiMove, 500);
                        }
                    } else {
                        selectedSquare = null;
                        possibleMoves = [];
                        renderBoard();
                    }
                }
            } catch (e) {
                console.error("Error in handleSquareClick:", e);
            }
        }

        function makeMove(move, realBoard = true) {
            const { from, to, type, special } = move;
            const piece = board[from[0]][from[1]];
            const target = board[to[0]][to[1]];

            // Sound Logic
            if (realBoard) {
                lastMove = { from, to };
                if (target || special === 'enpassant') {
                    SoundManager.capture();
                } else {
                    SoundManager.move();
                }
            }

            // Move piece
            board[to[0]][to[1]] = piece;
            board[from[0]][from[1]] = null;

            // Handle Special Moves
            if (special === 'castling') {
                if (to[1] === 6) { // King side
                    board[to[0]][5] = board[to[0]][7];
                    board[to[0]][7] = null;
                } else if (to[1] === 2) { // Queen side
                    board[to[0]][3] = board[to[0]][0];
                    board[to[0]][0] = null;
                }
            } else if (special === 'enpassant') {
                board[from[0]][to[1]] = null; // Capture pawn behind
            } else if (special === 'promotion') {
                piece.type = 'q'; // Auto promote
            }

            // Update State
            if (piece.type === 'k') {
                kingPositions[piece.color] = [to[0], to[1]];
                castlingRights[piece.color] = { k: false, q: false };
            }
            if (piece.type === 'r') {
                if (from[1] === 0) castlingRights[piece.color].q = false;
                if (from[1] === 7) castlingRights[piece.color].k = false;
            }

            // En Passant target
            if (piece.type === 'p' && Math.abs(from[0] - to[0]) === 2) {
                enPassantTarget = [(from[0] + to[0]) / 2, from[1]];
            } else {
                enPassantTarget = null;
            }

            // Switch turn
            turn = turn === 'white' ? 'black' : 'white';

            if (realBoard) {
                selectedSquare = null;
                possibleMoves = [];
                checkGameState();
            }
        }

        function checkGameState() {
            const moves = getValidMoves(board, turn);
            if (moves.length === 0) {
                SoundManager.gameOver();
                if (isInCheck(board, turn)) {
                    statusElement.textContent = `Checkmate! ${turn === 'white' ? 'Black' : 'White'} wins!`;
                    gameActive = false;
                } else {
                    statusElement.textContent = "Stalemate! It's a draw.";
                    gameActive = false;
                }
            } else {
                if (isInCheck(board, turn)) {
                    statusElement.textContent = `${turn === 'white' ? "White" : "Black"}'s Turn (Check!)`;
                } else {
                    statusElement.textContent = `${turn === 'white' ? "White" : "Black"}'s Turn`;
                }
            }
        }

        function getValidMoves(currentBoard, color) {
            let moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.color === color) {
                        moves.push(...getPieceMoves(currentBoard, r, c, piece));
                    }
                }
            }
            // Filter moves that leave king in check
            return moves.filter(move => {
                const tempBoard = JSON.parse(JSON.stringify(currentBoard));
                // Apply move on temp board
                tempBoard[move.to[0]][move.to[1]] = tempBoard[move.from[0]][move.from[1]];
                tempBoard[move.from[0]][move.from[1]] = null;

                let kPos = kingPositions[color];
                if (tempBoard[move.to[0]][move.to[1]].type === 'k') {
                    kPos = [move.to[0], move.to[1]];
                }

                return !isSquareUnderAttack(tempBoard, kPos[0], kPos[1], color === 'white' ? 'black' : 'white');
            });
        }

        function getPieceMoves(b, r, c, piece) {
            const moves = [];
            const directions = {
                'r': [[0, 1], [0, -1], [1, 0], [-1, 0]],
                'b': [[1, 1], [1, -1], [-1, 1], [-1, -1]],
                'n': [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]],
                'q': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]],
                'k': [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]]
            };

            const addMove = (tr, tc, special = null) => {
                moves.push({ from: [r, c], to: [tr, tc], type: piece.type, special });
            };

            if (piece.type === 'p') {
                const dir = piece.color === 'white' ? -1 : 1;
                const startRow = piece.color === 'white' ? 6 : 1;

                // Move forward 1
                if (!b[r + dir][c]) {
                    if (r + dir === 0 || r + dir === 7) addMove(r + dir, c, 'promotion');
                    else addMove(r + dir, c);

                    // Move forward 2
                    if (r === startRow && !b[r + dir * 2][c]) {
                        addMove(r + dir * 2, c);
                    }
                }

                // Captures
                [[r + dir, c - 1], [r + dir, c + 1]].forEach(([tr, tc]) => {
                    if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                        const target = b[tr][tc];
                        if (target && target.color !== piece.color) {
                            if (tr === 0 || tr === 7) addMove(tr, tc, 'promotion');
                            else addMove(tr, tc);
                        }
                        // En Passant
                        if (!target && enPassantTarget && enPassantTarget[0] === tr && enPassantTarget[1] === tc) {
                            addMove(tr, tc, 'enpassant');
                        }
                    }
                });
            } else {
                const dirs = directions[piece.type];
                const isSliding = ['r', 'b', 'q'].includes(piece.type);

                for (let d of dirs) {
                    let tr = r + d[0];
                    let tc = c + d[1];

                    while (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                        const target = b[tr][tc];
                        if (!target) {
                            addMove(tr, tc);
                        } else {
                            if (target.color !== piece.color) {
                                addMove(tr, tc);
                            }
                            break; // Blocked
                        }
                        if (!isSliding) break;
                        tr += d[0];
                        tc += d[1];
                    }
                }
            }

            // Castling
            if (piece.type === 'k' && !isInCheck(b, piece.color)) {
                if (castlingRights[piece.color].k) {
                    if (!b[r][5] && !b[r][6] &&
                        !isSquareUnderAttack(b, r, 5, piece.color === 'white' ? 'black' : 'white') &&
                        !isSquareUnderAttack(b, r, 6, piece.color === 'white' ? 'black' : 'white')) {
                        addMove(r, 6, 'castling');
                    }
                }
                if (castlingRights[piece.color].q) {
                    if (!b[r][1] && !b[r][2] && !b[r][3] &&
                        !isSquareUnderAttack(b, r, 3, piece.color === 'white' ? 'black' : 'white')) {
                        addMove(r, 2, 'castling');
                    }
                }
            }

            return moves;
        }

        function isInCheck(b, color) {
            const kPos = kingPositions[color];
            return isSquareUnderAttack(b, kPos[0], kPos[1], color === 'white' ? 'black' : 'white');
        }

        function isSquareUnderAttack(b, r, c, attackerColor) {
            const pawnDir = attackerColor === 'white' ? -1 : 1;
            const pRow = r - pawnDir;
            if (pRow >= 0 && pRow < 8) {
                if (c - 1 >= 0) {
                    const p = b[pRow][c - 1];
                    if (p && p.color === attackerColor && p.type === 'p') return true;
                }
                if (c + 1 < 8) {
                    const p = b[pRow][c + 1];
                    if (p && p.color === attackerColor && p.type === 'p') return true;
                }
            }

            const knightMoves = [[2, 1], [2, -1], [-2, 1], [-2, -1], [1, 2], [1, -2], [-1, 2], [-1, -2]];
            for (let m of knightMoves) {
                const tr = r + m[0], tc = c + m[1];
                if (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                    const p = b[tr][tc];
                    if (p && p.color === attackerColor && p.type === 'n') return true;
                }
            }

            const dirs = [
                [0, 1], [0, -1], [1, 0], [-1, 0],
                [1, 1], [1, -1], [-1, 1], [-1, -1]
            ];

            for (let i = 0; i < dirs.length; i++) {
                const d = dirs[i];
                let tr = r + d[0];
                let tc = c + d[1];
                let dist = 0;

                while (tr >= 0 && tr < 8 && tc >= 0 && tc < 8) {
                    dist++;
                    const p = b[tr][tc];
                    if (p) {
                        if (p.color === attackerColor) {
                            const type = p.type;
                            if (type === 'q') return true;
                            if (type === 'k' && dist === 1) return true;
                            if (i < 4 && type === 'r') return true;
                            if (i >= 4 && type === 'b') return true;
                        }
                        break;
                    }
                    tr += d[0];
                    tc += d[1];
                }
            }

            return false;
        }

        const pieceValues = { p: 10, n: 30, b: 30, r: 50, q: 90, k: 900 };

        function evaluateBoard(b) {
            let score = 0;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const p = b[r][c];
                    if (p) {
                        const val = pieceValues[p.type];
                        score += p.color === 'white' ? val : -val;
                        if ((r === 3 || r === 4) && (c === 3 || c === 4)) {
                            score += p.color === 'white' ? 1 : -1;
                        }
                    }
                }
            }
            return score;
        }

        function aiMove() {
            if (!gameActive) return;
            const moves = getValidMoves(board, 'black');
            if (moves.length === 0) return;
            let bestMove = null;
            if (currentDifficulty === 'easy') {
                bestMove = moves[Math.floor(Math.random() * moves.length)];
            } else if (currentDifficulty === 'medium') {
                bestMove = getBestMove(2);
            } else {
                bestMove = getBestMove(3);
            }
            if (bestMove) {
                makeMove(bestMove);
                renderBoard();
            }
        }

        function getBestMove(depth) {
            let bestScore = Infinity;
            let bestMove = null;
            const moves = getValidMoves(board, 'black');
            moves.sort((a, b) => {
                const pieceA = board[a.to[0]][a.to[1]];
                const pieceB = board[b.to[0]][b.to[1]];
                return (pieceB ? pieceValues[pieceB.type] : 0) - (pieceA ? pieceValues[pieceA.type] : 0);
            });

            for (let move of moves) {
                const nextBoard = simulateMove(board, move);
                const score = minimax(nextBoard, depth - 1, -Infinity, Infinity, true);

                if (score < bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        function simulateMove(currentBoard, move) {
            const newBoard = JSON.parse(JSON.stringify(currentBoard));
            const { from, to } = move;
            newBoard[to[0]][to[1]] = newBoard[from[0]][from[1]];
            newBoard[from[0]][from[1]] = null;
            return newBoard;
        }

        function minimax(b, depth, alpha, beta, isMaximizing) {
            if (depth === 0) {
                return evaluateBoard(b);
            }
            if (isMaximizing) {
                // White
                let maxEval = -Infinity;
                const moves = getAllPseudoMoves(b, 'white');
                for (let move of moves) {
                    const nextBoard = simulateMove(b, move);
                    const eval = minimax(nextBoard, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, eval);
                    alpha = Math.max(alpha, eval);
                    if (beta <= alpha) break;
                }
                return maxEval === -Infinity ? evaluateBoard(b) : maxEval;
            } else {
                // Black
                let minEval = Infinity;
                const moves = getAllPseudoMoves(b, 'black');
                for (let move of moves) {
                    const nextBoard = simulateMove(b, move);
                    const eval = minimax(nextBoard, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, eval);
                    beta = Math.min(beta, eval);
                    if (beta <= alpha) break;
                }
                return minEval === Infinity ? evaluateBoard(b) : minEval;
            }
        }

        function getAllPseudoMoves(b, color) {
            let moves = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = b[r][c];
                    if (piece && piece.color === color) {
                        moves.push(...getPieceMoves(b, r, c, piece));
                    }
                }
            }
            return moves;
        }

        // --- Input Handling ---
        document.addEventListener('keydown', (e) => {
            const key = e.key;
            const keyCode = e.keyCode;

            // TV Keys
            const TV_LEFT = 37;
            const TV_RIGHT = 39;
            const TV_UP = 38;
            const TV_DOWN = 40;
            const TV_ENTER = 13;

            // Alternate TV Keys
            const ALT_LEFT = 21;
            const ALT_RIGHT = 22;
            const ALT_UP = 19;
            const ALT_DOWN = 20;
            const ALT_ENTER = 23;
            const ALT_BACK = 4;
            const TIZEN_BACK = 10009;

            let handled = false;

            // Handle Back Button
            if (key === 'Backspace' || key === 'Escape' || keyCode === 8 || keyCode === 27 || keyCode === 461 || keyCode === TIZEN_BACK || keyCode === ALT_BACK) {
                window.location.href = 'index.html';
                handled = true;
            }

            if (modalElement.style.display !== 'none') {
                if (['2', '8', 'ArrowUp', 'ArrowDown'].includes(key) || [TV_UP, TV_DOWN, ALT_UP, ALT_DOWN].includes(keyCode)) {
                    handleModalInput(key, keyCode);
                    handled = true;
                } else if (['5', 'Enter', ' '].includes(key) || [TV_ENTER, ALT_ENTER].includes(keyCode)) {
                    handleModalInput(key, keyCode);
                    handled = true;
                }
            } else if (gameActive) {
                if (['2', '8', '4', '6', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key) ||
                    [TV_UP, TV_DOWN, TV_LEFT, TV_RIGHT, ALT_UP, ALT_DOWN, ALT_LEFT, ALT_RIGHT].includes(keyCode)) {
                    handleGameInput(key, keyCode);
                    handled = true;
                } else if (['5', 'Enter', ' '].includes(key) || [TV_ENTER, ALT_ENTER].includes(keyCode)) {
                    handleGameInput(key, keyCode);
                    handled = true;
                }
            } else {
                // Game Over State
                if (['5', 'Enter', ' '].includes(key) || [TV_ENTER, ALT_ENTER].includes(keyCode)) {
                    resetGame();
                    handled = true;
                }
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        function handleModalInput(key, keyCode) {
            const buttons = Array.from(document.querySelectorAll('.difficulty-btn'));
            let focusIndex = buttons.indexOf(document.activeElement);

            // TV Keys
            const TV_UP = 38;
            const TV_DOWN = 40;
            const TV_ENTER = 13;

            // Alternate TV Keys
            const ALT_UP = 19;
            const ALT_DOWN = 20;
            const ALT_ENTER = 23;

            if (focusIndex === -1) {
                buttons[0].focus();
                return;
            }

            if (['2', 'ArrowUp'].includes(key) || keyCode === TV_UP || keyCode === ALT_UP) {
                focusIndex = (focusIndex - 1 + buttons.length) % buttons.length;
                buttons[focusIndex].focus();
            } else if (['8', 'ArrowDown'].includes(key) || keyCode === TV_DOWN || keyCode === ALT_DOWN) {
                focusIndex = (focusIndex + 1) % buttons.length;
                buttons[focusIndex].focus();
            } else if (['5', 'Enter', ' '].includes(key) || keyCode === TV_ENTER || keyCode === ALT_ENTER) {
                buttons[focusIndex].click();
            }
        }

        function moveCursor(newR, newC) {
            cursor = [newR, newC];
            renderBoard();
        }

        function handleGameInput(key, keyCode) {
            // TV Keys
            const TV_LEFT = 37;
            const TV_RIGHT = 39;
            const TV_UP = 38;
            const TV_DOWN = 40;
            const TV_ENTER = 13;

            // Alternate TV Keys
            const ALT_LEFT = 21;
            const ALT_RIGHT = 22;
            const ALT_UP = 19;
            const ALT_DOWN = 20;
            const ALT_ENTER = 23;

            const press = (action) => {
                clearInterval(cursorHoldInterval);
                action();
                cursorHoldInterval = setInterval(action, 100);
            };

            if (['2', 'ArrowUp'].includes(key) || [TV_UP, ALT_UP].includes(keyCode))
                press(() => moveCursor(Math.max(0, cursor[0] - 1), cursor[1]));

            else if (['8', 'ArrowDown'].includes(key) || [TV_DOWN, ALT_DOWN].includes(keyCode))
                press(() => moveCursor(Math.min(7, cursor[0] + 1), cursor[1]));

            else if (['4', 'ArrowLeft'].includes(key) || [TV_LEFT, ALT_LEFT].includes(keyCode))
                press(() => moveCursor(cursor[0], Math.max(0, cursor[1] - 1)));

            else if (['6', 'ArrowRight'].includes(key) || [TV_RIGHT, ALT_RIGHT].includes(keyCode))
                press(() => moveCursor(cursor[0], Math.min(7, cursor[1] + 1)));

            else if (['5', 'Enter', ' '].includes(key) || [TV_ENTER, ALT_ENTER].includes(keyCode))
                handleSquareClick(cursor[0], cursor[1]);
        }

        // Check URL params for mode
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');

        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
        }

        if (mode) {
            document.body.classList.add('mode-' + mode);
        } else if (isTouchDevice()) {
            document.body.classList.add('mode-mobile');
        }

        // Init
        showDifficultyModal();

        // Focus modal on load
        window.onload = () => {
            showDifficultyModal();
        };

        // Keep focus
        gameContainer.addEventListener('blur', () => {
            if (gameActive && modalElement.style.display === 'none') {
                setTimeout(() => gameContainer.focus(), 50);
            }
        });

        document.addEventListener("keyup", () => clearInterval(cursorHoldInterval));
    </script>
    <script src="global.js"></script>
</body>

</html>