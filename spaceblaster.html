<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1280, initial-scale=1">
    <title>Space Blaster | Man Games</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary: #AC92EC;
            --accent: #4FC1E9;
            --bg: #2D3436;
            --text: #F5F7FA;
            --enemy: #ED5565;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Fredoka', sans-serif;
            background: radial-gradient(circle at center, #1B2735 0%, #090A0F 100%);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
            touch-action: none;
        }

        .game-container {
            position: relative;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(79, 193, 233, 0.3);
            border: 2px solid #4FC1E9;
            outline: none;
        }

        canvas {
            background: transparent;
            border-radius: 15px;
            display: block;
            cursor: none;
        }

        .ui-panel {
            display: flex;
            justify-content: space-between;
            width: 100%;
            max-width: 500px;
            margin-bottom: 0.5rem;
            padding: 0 5px;
            align-items: center;
        }

        .score-box {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 15px;
            border-radius: 15px;
            font-size: 1rem;
            font-weight: 700;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 10px 25px;
            border-radius: 50px;
            font-family: inherit;
            font-weight: 700;
            font-size: 1rem;
            cursor: pointer;
            box-shadow: 0 0 15px rgba(79, 193, 233, 0.5);
            transition: all 0.2s;
        }

        .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(79, 193, 233, 0.8);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #fff;
            box-shadow: none;
        }

        .btn-home {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            margin-top: 15px;
            text-decoration: none;
            display: inline-block;
            padding: 8px 20px;
            border-radius: 50px;
            color: white;
            font-weight: 700;
            font-size: 0.9rem;
            backdrop-filter: blur(5px);
            transition: all 0.2s;
        }

        .btn-home:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        /* Overlays */
        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.95);
            padding: 2rem;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(79, 193, 233, 0.2);
            min-width: 320px;
            z-index: 10;
            border: 1px solid rgba(79, 193, 233, 0.3);
        }

        #startScreen {
            display: block;
        }

        #gameOverModal {
            display: none;
        }

        h1 {
            color: var(--accent);
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px var(--accent);
        }

        h2 {
            color: #fff;
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .final-score {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            color: #fff;
        }

        .name-input {
            margin: 10px 0;
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #4FC1E9;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            font-family: inherit;
            font-size: 1rem;
            width: 80%;
            display: none;
            text-align: center;
        }

        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .controls-hint {
            margin-top: 1rem;
            color: #888;
            font-size: 0.9rem;
            text-align: center;
        }

        .fire-btn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 80px;
            height: 80px;
            background: rgba(237, 85, 101, 0.6);
            border: 4px solid #fff;
            border-radius: 50%;
            color: white;
            font-size: 30px;
            display: none;
            align-items: center;
            justify-content: center;
            user-select: none;
            z-index: 100;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(237, 85, 101, 0.4);
            touch-action: manipulation;
        }

        .fire-btn:active {
            transform: scale(0.95);
            background: rgba(237, 85, 101, 0.8);
        }

        @media (hover: none) and (pointer: coarse) {
            .fire-btn {
                display: flex;
            }
        }

        /* TV Mode */
        body.mode-tv {
            cursor: none;
        }

        body.mode-tv .btn:focus {
            outline: 5px solid var(--accent);
            transform: scale(1.1);
        }
    </style>
</head>

<body>

    <div class="ui-panel">
        <div class="score-box">🚀 <span id="score">0</span></div>
        <div class="score-box">🌊 Wave: <span id="waveDisplay">1</span></div>
        <div class="score-box">🏆 <span id="highScoreText">Player</span>: <span id="highScore">0</span></div>
        <div class="score-box">❤️ <span id="lives">3</span></div>
        <button class="btn btn-secondary" style="padding: 5px 15px; font-size: 0.8rem;"
            onclick="toggleFullScreen()">⛶</button>
    </div>

    <div class="game-container" id="gameContainer" tabindex="0">
        <canvas id="gameCanvas" width="500" height="600"></canvas>

        <!-- Start Screen -->
        <div id="startScreen" class="overlay">
            <h1>SPACE BLASTER</h1>
            <h2>Defend the Galaxy!</h2>
            <button class="btn" onclick="startGame()">LAUNCH MISSION</button>
            <p class="controls-hint">Mouse/Numpad (4,6) to Move • Left Click/5 to Toggle Auto-Shoot • F for Fullscreen
            </p>
        </div>

        <!-- Game Over Modal -->
        <div id="gameOverModal" class="overlay">
            <h1 id="gameOverTitle" style="color: #ED5565;">MISSION FAILED</h1>
            <p class="final-score">Score: <span id="finalScore">0</span></p>
            <input type="text" id="playerNameInput" class="name-input" placeholder="Enter your name" maxlength="10">
            <div class="button-group">
                <button class="btn" onclick="handleGameOverAction()">RETRY</button>
                <button class="btn btn-secondary" onclick="showStartScreen()">MENU</button>
            </div>
        </div>

        <div id="fireBtn" class="fire-btn">🔥</div>
    </div>

    <a href="index.html" class="btn btn-home">🏠 BACK TO HOME</a>

    <script>
        // Sound Manager
        const SoundManager = {
            ctx: null,

            init() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)(),
                        this.ctx.resume();
                } catch (e) {
                    console.warn("AudioContext not supported or failed to init", e);
                }
            },

            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                try {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, this.ctx.currentTime);

                    gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

                    osc.connect(gain);
                    gain.connect(this.ctx.destination);

                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                } catch (e) {
                    console.warn("Audio error:", e);
                }
            },

            playLaser() {
                this.playTone(800, 'sawtooth', 0.1, 0.05);
                setTimeout(() => this.playTone(600, 'sawtooth', 0.1, 0.05), 50);
            },

            playExplosion() {
                this.playTone(150, 'sawtooth', 0.1, 0.2);
                setTimeout(() => this.playTone(50, 'square', 0.2, 0.2), 50);
            },

            playExplosionHeavy() {
                this.playTone(100, 'square', 0.3, 0.3);
                setTimeout(() => this.playTone(40, 'sawtooth', 0.4, 0.3), 100);
            },

            playExplosionZap() {
                this.playTone(300, 'sawtooth', 0.1, 0.2);
                this.playTone(100, 'sine', 0.2, 0.2);
            },

            playBossExplosion() {
                this.playTone(100, 'sawtooth', 0.5, 0.4);
                setTimeout(() => this.playTone(80, 'square', 0.5, 0.4), 200);
                setTimeout(() => this.playTone(60, 'sawtooth', 0.8, 0.4), 400);
                setTimeout(() => this.playTone(40, 'square', 1.0, 0.4), 600);
            },

            playPowerup() {
                this.playTone(600, 'sine', 0.1, 0.1);
                setTimeout(() => this.playTone(900, 'sine', 0.2, 0.1), 100);
            }
        };

        try {
            SoundManager.init();
        } catch (e) {
            console.error("SoundManager init failed", e);
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const waveEl = document.getElementById('waveDisplay');
        const livesEl = document.getElementById('lives');
        const highScoreEl = document.getElementById('highScore');
        const highScoreTextEl = document.getElementById('highScoreText');
        const startScreen = document.getElementById('startScreen');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreEl = document.getElementById('finalScore');
        const nameInput = document.getElementById('playerNameInput');
        const gameOverTitle = document.getElementById('gameOverTitle');

        // Game State
        let score = 0;
        let wave = 1;
        let highScore = 0;
        let highScoreName = 'Player';
        let lives = 3;
        let isGameOver = false;
        let frameCount = 0;

        // Player
        const player = {
            x: canvas.width / 2,
            y: canvas.height - 80,
            width: 40,
            height: 40,
            speed: 5,
            color: '#4FC1E9',
            weaponType: 'normal', // normal, laser, tracking
            bulletCount: 1, // 1, 2, 3, 4
            summon: {
                active: false,
                level: 0,
                x: 0,
                y: 0,
                angle: 0,
                bossData: null,
                shootTimer: 0
            }
        };

        // Entities
        let bullets = [];
        let enemyBullets = [];
        let enemies = [];
        let particles = [];
        let powerups = [];
        let stars = [];

        // Wave Management
        let waveInProgress = false;
        let enemiesToSpawn = [];
        let spawnTimer = 0;
        let bossActive = false;

        // Input
        let mouseX = canvas.width / 2;
        let isMouseDown = false;
        let shootTimer = 0;
        let isAutoShooting = false;
        let keys = {};

        // Enemy Types
        const EnemyTypes = {
            BASIC: { type: 'basic', hp: 1, speed: 2, color: '#ED5565', size: 30, score: 100, eyeColor: 'white' },
            FAST: { type: 'fast', hp: 1, speed: 5, color: '#FFCE54', size: 25, score: 200, eyeColor: 'red' },
            TANK: { type: 'tank', hp: 6, speed: 1, color: '#DA4453', size: 50, score: 300, eyeColor: 'yellow' },
            SHOOTER: { type: 'shooter', hp: 3, speed: 1.5, color: '#AC92EC', size: 35, score: 250, shootRate: 100, eyeColor: 'cyan' },
            ZIGZAG: { type: 'zigzag', hp: 2, speed: 2.5, color: '#A0D468', size: 30, score: 250, eyeColor: 'purple' }
        };

        // Boss Definitions
        const Bosses = [
            {
                name: "The Guardian",
                hp: 100,
                color: '#D8334A',
                size: 80,
                pattern: 'shield',
                speed: 1,
                summonType: EnemyTypes.BASIC
            },
            {
                name: "Speedster",
                hp: 150,
                color: '#4FC1E9',
                size: 60,
                pattern: 'tracking',
                speed: 3,
                summonType: EnemyTypes.FAST
            },
            {
                name: "Iron Clad",
                hp: 300,
                color: '#656D78',
                size: 100,
                pattern: 'tank',
                speed: 0.5,
                summonType: EnemyTypes.TANK
            },
            {
                name: "Swarm Lord",
                hp: 200,
                color: '#967ADC',
                size: 90,
                pattern: 'swarm',
                speed: 1,
                summonType: EnemyTypes.BASIC
            },
            {
                name: "Laser Eye",
                hp: 250,
                color: '#E9573F',
                size: 85,
                pattern: 'laser',
                speed: 1.5,
                summonType: EnemyTypes.SHOOTER
            },
            {
                name: "The Mothership",
                hp: 500,
                color: '#F6BB42',
                size: 120,
                pattern: 'omega',
                speed: 0.8,
                summonType: EnemyTypes.ZIGZAG
            }
        ];

        loadHighScore();
        initStars();

        function loadHighScore() {
            highScore = localStorage.getItem('spaceBlasterHighScore') || 0;
            highScoreName = localStorage.getItem('spaceBlasterHighScoreName') || 'Player';
            highScoreEl.textContent = highScore;
            highScoreTextEl.textContent = highScoreName;
        }

        function saveHighScore(newScore, newName) {
            if (newScore > highScore) {
                highScore = newScore;
                highScoreName = newName;
                localStorage.setItem('spaceBlasterHighScore', highScore);
                localStorage.setItem('spaceBlasterHighScoreName', highScoreName);
                highScoreEl.textContent = highScore;
                highScoreTextEl.textContent = highScoreName;
            }
        }

        function initStars() {
            for (let i = 0; i < 50; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2,
                    speed: Math.random() * 1 + 0.2
                });
            }
        }

        function startGame() {
            startScreen.style.display = 'none';
            gameOverModal.style.display = 'none';
            if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') SoundManager.ctx.resume();

            resetGame();
            requestAnimationFrame(update);
        }

        function resetGame() {
            score = 0;
            lives = 3;
            wave = 1;
            player.weaponType = 'normal';
            player.bulletCount = 1;
            player.x = canvas.width / 2;
            player.summon = { active: false, level: 0, x: 0, y: 0, angle: 0, bossData: null, shootTimer: 0 };

            bullets = [];
            enemyBullets = [];
            enemies = [];
            particles = [];
            powerups = [];
            enemiesToSpawn = [];

            waveInProgress = false;
            bossActive = false;
            isGameOver = false;

            startWave(1);
            updateUI();
        }

        function focusFirstButton(container) {
            const btn = container.querySelector("button");
            if (btn) btn.focus();
        }

        function showStartScreen() {
            gameOverModal.style.display = 'none';
            startScreen.style.display = 'block';
            isGameOver = true;
            focusFirstButton(startScreen);
        }

        function handleGameOverAction() {
            if (nameInput.style.display !== 'none') {
                const name = nameInput.value.trim() || 'Anonymous';
                saveHighScore(score, name);
            }
            startGame();
        }

        function update() {
            if (isGameOver) return;

            try {
                frameCount++;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                updateStars();
                updatePlayer();
                updateSummon();
                updateBullets();
                updateEnemyBullets();
                updateEnemies();
                updatePowerups();
                updateParticles();
                updateWave();

                drawStars();
                drawPlayer();
                drawSummon();
                drawBullets();
                drawEnemyBullets();
                drawEnemies();
                drawPowerups();
                drawParticles();
                drawBossHealth();

                requestAnimationFrame(update);
            } catch (error) {
                console.error("Game Loop Error:", error);
                ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "red";
                ctx.font = "16px Arial";
                ctx.textAlign = "left";
                ctx.fillText("Error: " + error.message, 10, 50);
                ctx.fillText("Check console for details", 10, 80);
            }
        }

        function startWave(waveNum) {
            wave = waveNum;
            waveInProgress = true;
            bossActive = false;
            enemiesToSpawn = [];

            if (wave % 5 === 0) {
                let bossIndex = (wave / 5) - 1;
                let actualBossIndex = bossIndex % Bosses.length;
                let difficultyMultiplier = 1 + Math.floor(bossIndex / Bosses.length) * 0.5;

                spawnBoss(Bosses[actualBossIndex], difficultyMultiplier);
            } else {
                let enemyCount = 5 + wave * 2;
                for (let i = 0; i < enemyCount; i++) {
                    let type = EnemyTypes.BASIC;
                    let rand = Math.random();

                    if (wave > 1 && rand > 0.8) type = EnemyTypes.FAST;
                    if (wave > 2 && rand > 0.7) type = EnemyTypes.ZIGZAG;
                    if (wave > 3 && rand > 0.6) type = EnemyTypes.SHOOTER;
                    if (wave > 4 && rand > 0.8) type = EnemyTypes.TANK;

                    enemiesToSpawn.push(type);
                }
            }

            const waveText = document.createElement('div');
            waveText.innerText = `WAVE ${wave}`;
            waveText.style.position = 'absolute';
            waveText.style.top = '40%';
            waveText.style.left = '50%';
            waveText.style.transform = 'translate(-50%, -50%)';
            waveText.style.color = '#FFF';
            waveText.style.fontSize = '4rem';
            waveText.style.fontWeight = 'bold';
            waveText.style.textShadow = '0 0 20px #4FC1E9';
            waveText.style.zIndex = '100';
            waveText.style.opacity = '0';
            waveText.style.transition = 'opacity 0.5s';
            document.querySelector('.game-container').appendChild(waveText);

            setTimeout(() => waveText.style.opacity = '1', 100);
            setTimeout(() => {
                waveText.style.opacity = '0';
                setTimeout(() => waveText.remove(), 500);
            }, 2000);

            updateUI();
        }

        function updateWave() {
            if (!waveInProgress) return;

            if (bossActive) {
                if (enemies.length === 0) {
                    bossActive = false;
                    waveInProgress = false;
                    setTimeout(() => startWave(wave + 1), 3000);
                }
                return;
            }

            if (enemiesToSpawn.length > 0) {
                spawnTimer++;
                if (spawnTimer > 30) {
                    let type = enemiesToSpawn.shift();
                    spawnEnemy(type);
                    spawnTimer = 0;
                }
            } else if (enemies.length === 0) {
                waveInProgress = false;
                setTimeout(() => startWave(wave + 1), 2000);
            }
        }

        function spawnBoss(bossData, multiplier) {
            bossActive = true;
            enemies.push({
                x: canvas.width / 2,
                y: -100,
                size: bossData.size,
                hp: bossData.hp * multiplier,
                maxHp: bossData.hp * multiplier,
                speed: bossData.speed,
                color: bossData.color,
                isBoss: true,
                name: bossData.name,
                pattern: bossData.pattern,
                summonType: bossData.summonType,
                shootTimer: 0,
                moveTimer: 0,
                summonTimer: 0,
                targetX: canvas.width / 2,
                shieldEntities: [],
                state: 'attack',
                originalData: bossData // Store reference for summon
            });
        }

        function spawnEnemy(type, x, y) {
            let size = type.size;
            let spawnX = x !== undefined ? x : Math.random() * (canvas.width - size) + size / 2;
            let spawnY = y !== undefined ? y : -size;

            enemies.push({
                x: spawnX,
                y: spawnY,
                size: size,
                hp: type.hp,
                maxHp: type.hp,
                speed: type.speed,
                color: type.color,
                type: type.type,
                score: type.score,
                eyeColor: type.eyeColor,
                shootTimer: Math.random() * 100,
                startX: spawnX,
                time: 0,
                returning: false,
                wobbleOffset: Math.random() * 100
            });
        }

        function updateStars() {
            stars.forEach(star => {
                star.y += star.speed;
                if (star.y > canvas.height) {
                    star.y = 0;
                    star.x = Math.random() * canvas.width;
                }
            });
        }

        function updatePlayer() {
            // Keyboard Movement
            let moving = false;

            // TV Keys
            const TV_LEFT = 37;
            const TV_RIGHT = 39;
            const TV_UP = 38;
            const TV_DOWN = 40;

            // Alternate TV Keys
            const ALT_LEFT = 21;
            const ALT_RIGHT = 22;
            const ALT_UP = 19;
            const ALT_DOWN = 20;

            if (keys['4'] || keys['ArrowLeft'] || keys[TV_LEFT] || keys[ALT_LEFT]) { player.x -= player.speed; moving = true; }
            if (keys['6'] || keys['ArrowRight'] || keys[TV_RIGHT] || keys[ALT_RIGHT]) { player.x += player.speed; moving = true; }
            if (keys['8'] || keys['ArrowUp'] || keys[TV_UP] || keys[ALT_UP]) { player.y -= player.speed; moving = true; }
            if (keys['2'] || keys['ArrowDown'] || keys[TV_DOWN] || keys[ALT_DOWN]) { player.y += player.speed; moving = true; }

            if (moving) {
                mouseX = player.x;
            } else {
                player.x += (mouseX - player.x) * 0.2;
            }
            if (player.x < player.width / 2) player.x = player.width / 2;
            if (player.x > canvas.width - player.width / 2) player.x = canvas.width - player.width / 2;
            if (player.y < player.height / 2) player.y = player.height / 2;
            if (player.y > canvas.height - player.height / 2) player.y = canvas.height - player.height / 2;

            if (isAutoShooting) {
                if (shootTimer <= 0) {
                    shoot();
                    // Cooldown depends on weapon
                    if (player.weaponType === 'laser') {
                        shootTimer = 45; // 0.75s
                    } else {
                        shootTimer = 10;
                    }
                }
            }
            if (shootTimer > 0) shootTimer--;
        }

        function updateSummon() {
            if (!player.summon.active) return;

            // Orbit
            player.summon.angle += 0.02;
            let radius = 60;
            player.summon.x = player.x + Math.cos(player.summon.angle) * radius;
            player.summon.y = player.y + Math.sin(player.summon.angle) * radius;

            // Shoot
            player.summon.shootTimer++;
            if (player.summon.shootTimer > 60) {
                // Find nearest enemy
                let nearest = null;
                let minDst = Infinity;
                enemies.forEach(e => {
                    let dst = Math.hypot(e.x - player.summon.x, e.y - player.summon.y);
                    if (dst < minDst) {
                        minDst = dst;
                        nearest = e;
                    }
                });

                if (nearest) {
                    // Shoot towards nearest
                    let dx = nearest.x - player.summon.x;
                    let dy = nearest.y - player.summon.y;
                    let angle = Math.atan2(dy, dx);

                    bullets.push({
                        x: player.summon.x,
                        y: player.summon.y,
                        vx: Math.cos(angle) * 5,
                        vy: Math.sin(angle) * 5,
                        color: player.summon.bossData.color,
                        type: 'summon_projectile',
                        damage: 0.2 // Small damage
                    });
                    player.summon.shootTimer = 0;
                }
            }
        }

        function shoot() {
            SoundManager.playLaser();

            if (player.weaponType === 'laser') {
                bullets.push({
                    x: player.x,
                    y: player.y - 40,
                    vx: 0,
                    vy: -20, // Very fast
                    color: '#FF0000',
                    type: 'laser',
                    width: 10,
                    height: 60,
                    damage: 5, // High damage
                    penetrate: true
                });
                return;
            }

            if (player.weaponType === 'tracking') {
                bullets.push({
                    x: player.x,
                    y: player.y - 20,
                    vx: 0,
                    vy: -5,
                    color: '#00FF00',
                    type: 'tracking',
                    damage: 0.5 // Increased from 0.25
                });
                return;
            }

            // Normal Weapon (B1, B2, B3, B4)
            let count = player.bulletCount;
            let spread = 10;

            if (count === 1) {
                bullets.push({ x: player.x, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
            } else if (count === 2) {
                bullets.push({ x: player.x - 10, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x + 10, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
            } else if (count === 3) {
                bullets.push({ x: player.x, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x - 15, y: player.y - 20, vx: -1, vy: -10, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x + 15, y: player.y - 20, vx: 1, vy: -10, color: '#4FC1E9', damage: 1 });
            } else if (count >= 4) {
                bullets.push({ x: player.x - 10, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x + 10, y: player.y - 20, vx: 0, vy: -10, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x - 20, y: player.y - 20, vx: -2, vy: -9, color: '#4FC1E9', damage: 1 });
                bullets.push({ x: player.x + 20, y: player.y - 20, vx: 2, vy: -9, color: '#4FC1E9', damage: 1 });
            }
        }

        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                let b = bullets[i];

                if (b.type === 'tracking') {
                    // Find nearest enemy
                    let nearest = null;
                    let minDst = Infinity;
                    enemies.forEach(e => {
                        let dst = Math.hypot(e.x - b.x, e.y - b.y);
                        if (dst < minDst) {
                            minDst = dst;
                            nearest = e;
                        }
                    });

                    if (nearest) {
                        let dx = nearest.x - b.x;
                        let dy = nearest.y - b.y;
                        let angle = Math.atan2(dy, dx);
                        // Steer
                        b.vx += Math.cos(angle) * 0.5;
                        b.vy += Math.sin(angle) * 0.5;
                        // Clamp speed
                        let speed = Math.hypot(b.vx, b.vy);
                        if (speed > 8) {
                            b.vx = (b.vx / speed) * 8;
                            b.vy = (b.vy / speed) * 8;
                        }
                    }
                }

                b.x += b.vx;
                b.y += b.vy;

                if (b.y < -50 || b.y > canvas.height + 50 || b.x < -50 || b.x > canvas.width + 50) {
                    bullets.splice(i, 1);
                }
            }
        }

        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                let e = enemies[i];

                if (e.isBoss) {
                    updateBoss(e);
                } else {
                    if (e.returning) {
                        e.y -= e.speed * 3;
                        if (e.vx) e.x += e.vx;
                        if (e.y < -50) {
                            enemies.splice(i, 1);
                            continue;
                        }
                    } else {
                        if (e.type === 'zigzag') {
                            e.y += e.speed;
                            e.time += 0.05;
                            e.x = e.startX + Math.sin(e.time) * 50;
                        } else {
                            e.y += e.speed;
                        }

                        if (e.y > canvas.height + 50) {
                            e.returning = true;
                            // Come back from side
                            if (Math.random() < 0.5) e.x = -e.size;
                            else e.x = canvas.width + e.size;

                            e.y = canvas.height + 50;
                            e.vx = (canvas.width / 2 - e.x) * 0.01; // Drift center
                        }
                    }

                    if (e.type === 'shooter' && !e.returning) {
                        e.shootTimer--;
                        if (e.shootTimer <= 0) {
                            enemyShoot(e);
                            e.shootTimer = 120;
                        }
                    }
                }

                let enemyDestroyed = false;

                // Collision with bullets
                for (let j = bullets.length - 1; j >= 0; j--) {
                    let b = bullets[j];

                    // Simple AABB collision
                    let hit = false;
                    if (b.type === 'laser') {
                        // Laser is a rectangle
                        if (b.x < e.x + e.size / 2 && b.x + b.width > e.x - e.size / 2 &&
                            b.y < e.y + e.size / 2 && b.y + b.height > e.y - e.size / 2) {
                            hit = true;
                        }
                    } else {
                        if (Math.abs(b.x - e.x) < e.size / 2 + 5 && Math.abs(b.y - e.y) < e.size / 2 + 5) {
                            hit = true;
                        }
                    }

                    if (hit) {
                        // Shield Check
                        if (e.isBoss && e.pattern === 'shield' && e.shieldEntities.length > 0) {
                            SoundManager.playTone(100, 'square', 0.1);
                            if (!b.penetrate) bullets.splice(j, 1);
                            createParticles(b.x, b.y, '#FFF', 2);
                            continue;
                        }

                        e.hp -= (b.damage || 1);
                        if (!b.penetrate) bullets.splice(j, 1);
                        createParticles(e.x, e.y, e.color, 2);

                        if (e.hp <= 0) {
                            destroyEnemy(e, i);
                            enemyDestroyed = true;
                            break;
                        }
                    }

                    // Shield Entity Collision
                    if (e.isBoss && e.shieldEntities) {
                        for (let k = e.shieldEntities.length - 1; k >= 0; k--) {
                            let s = e.shieldEntities[k];
                            if (Math.abs(b.x - s.x) < 15 && Math.abs(b.y - s.y) < 15) {
                                e.shieldEntities.splice(k, 1);
                                if (!b.penetrate) bullets.splice(j, 1);
                                createParticles(s.x, s.y, '#00FFFF', 5);
                                SoundManager.playExplosion();
                                break;
                            }
                        }
                    }
                }

                if (enemyDestroyed) continue;

                // Collision with player
                if (Math.abs(player.x - e.x) < (player.width / 2 + e.size / 2) && Math.abs(player.y - e.y) < (player.height / 2 + e.size / 2)) {
                    if (!e.isBoss) {
                        destroyEnemy(e, i);
                    } else {
                        playerHit();
                    }
                    playerHit();
                    continue;
                }
            }
        }

        function updateBoss(boss) {
            if (boss.y < 100) {
                boss.y += 2;
                return;
            }

            if (boss.pattern === 'shield') {
                if (!boss.shieldInitialized) {
                    boss.shieldEntities = [];
                    for (let i = 0; i < 6; i++) {
                        boss.shieldEntities.push({ angle: i * (Math.PI / 3), x: 0, y: 0 });
                    }
                    boss.shieldInitialized = true;
                }
                let radius = boss.size + 20;
                boss.shieldEntities.forEach(s => {
                    s.angle += 0.05;
                    s.x = boss.x + Math.cos(s.angle) * radius;
                    s.y = boss.y + Math.sin(s.angle) * radius;
                });
            }

            boss.summonTimer++;
            if (boss.summonTimer > 300) {
                boss.state = 'summon';
                boss.summonTimer = 0;
                boss.summonCount = 0;
            }

            if (boss.state === 'summon') {
                if (frameCount % 20 === 0) {
                    spawnEnemy(boss.summonType, boss.x + (Math.random() - 0.5) * 100, boss.y + 50);
                    boss.summonCount++;
                    createParticles(boss.x, boss.y + 50, '#FFF', 5);
                    if (boss.summonCount >= 5) {
                        boss.state = 'attack';
                    }
                }
                return;
            }

            boss.moveTimer++;
            boss.shootTimer++;

            if (boss.moveTimer > 60) {
                boss.targetX = Math.random() * (canvas.width - boss.size) + boss.size / 2;
                boss.moveTimer = 0;
            }
            boss.x += (boss.targetX - boss.x) * 0.05;

            let fireRate = 60;
            if (boss.pattern === 'rapid') fireRate = 20;
            if (boss.pattern === 'tank') fireRate = 100;
            if (boss.pattern === 'omega') fireRate = 30;
            if (boss.pattern === 'shield') fireRate = 80;

            if (boss.shootTimer > fireRate) {
                bossShoot(boss);
                boss.shootTimer = 0;
            }
        }

        function enemyShoot(e) {
            enemyBullets.push({
                x: e.x,
                y: e.y + e.size / 2,
                vx: 0,
                vy: 5,
                color: '#AC92EC',
                size: 6,
                type: 'normal'
            });
        }

        function bossShoot(boss) {
            SoundManager.playLaser();
            if (boss.pattern === 'shield') {
                enemyBullets.push({ x: boss.x, y: boss.y + boss.size / 2, vx: 0, vy: 6, color: boss.color, size: 8, type: 'normal' });
            } else if (boss.pattern === 'tracking') {
                enemyBullets.push({
                    x: boss.x, y: boss.y + boss.size / 2,
                    vx: 0, vy: 4,
                    color: boss.color, size: 8,
                    type: 'tracking'
                });
            } else if (boss.pattern === 'laser') {
                enemyBullets.push({
                    x: boss.x, y: boss.y + boss.size / 2,
                    vx: 0, vy: 5,
                    color: boss.color, size: 6,
                    type: 'sine',
                    time: 0,
                    startX: boss.x
                });
            } else if (boss.pattern === 'tank') {
                enemyBullets.push({ x: boss.x, y: boss.y + boss.size / 2, vx: 0, vy: 4, color: boss.color, size: 15, type: 'normal' });
            } else if (boss.pattern === 'swarm') {
                for (let i = 0; i < 5; i++) {
                    enemyBullets.push({ x: boss.x, y: boss.y + boss.size / 2, vx: Math.cos(i) * 3, vy: Math.sin(i) * 3 + 3, color: boss.color, size: 6, type: 'normal' });
                }
            } else if (boss.pattern === 'omega') {
                for (let i = 0; i < 8; i++) {
                    let angle = (frameCount * 0.1) + (i * (Math.PI * 2) / 8);
                    enemyBullets.push({ x: boss.x, y: boss.y, vx: Math.cos(angle) * 4, vy: Math.sin(angle) * 4, color: boss.color, size: 7, type: 'normal' });
                }
            }
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                let b = enemyBullets[i];

                if (b.type === 'tracking') {
                    if (b.y < canvas.height / 2) {
                        let dx = player.x - b.x;
                        b.vx = dx * 0.05;
                    }
                } else if (b.type === 'sine') {
                    b.time += 0.1;
                    b.x = b.startX + Math.sin(b.time) * 50;
                    b.startX += b.vx;
                }

                b.x += b.vx;
                b.y += b.vy;

                if (Math.abs(player.x - b.x) < player.width / 2 + b.size / 2 && Math.abs(player.y - b.y) < player.height / 2 + b.size / 2) {
                    playerHit();
                    enemyBullets.splice(i, 1);
                    continue;
                }

                if (b.y > canvas.height || b.y < 0 || b.x < 0 || b.x > canvas.width) {
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function destroyEnemy(e, index) {
            enemies.splice(index, 1);
            createParticles(e.x, e.y, e.color, 10);

            if (e.isBoss) {
                SoundManager.playBossExplosion();
                // Summon Logic
                player.summon.active = true;
                player.summon.level++;
                player.summon.bossData = e.originalData;
            } else if (e.type === 'tank') {
                SoundManager.playExplosionHeavy();
            } else if (e.type === 'shooter' || e.type === 'zigzag') {
                SoundManager.playExplosionZap();
            } else {
                SoundManager.playExplosion();
            }

            score += (e.score || 100);
            updateUI();

            if (Math.random() < 0.15) { // Increased drop rate slightly
                spawnPowerup(e.x, e.y);
            }
        }

        function spawnPowerup(x, y) {
            let types = ['B2', 'B3', 'B4', 'LASER', 'TRACK'];
            let type = types[Math.floor(Math.random() * types.length)];
            powerups.push({ x: x, y: y, vy: 2, type: type });
        }

        function updatePowerups() {
            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.y += p.vy;
                if (Math.abs(player.x - p.x) < 30 && Math.abs(player.y - p.y) < 30) {
                    SoundManager.playPowerup();
                    createParticles(p.x, p.y, '#FFF', 5);

                    if (p.type === 'B2') {
                        player.weaponType = 'normal';
                        player.bulletCount = 2;
                    } else if (p.type === 'B3') {
                        player.weaponType = 'normal';
                        player.bulletCount = 3;
                    } else if (p.type === 'B4') {
                        player.weaponType = 'normal';
                        player.bulletCount = 4;
                    } else if (p.type === 'LASER') {
                        player.weaponType = 'laser';
                    } else if (p.type === 'TRACK') {
                        player.weaponType = 'tracking';
                    }

                    powerups.splice(i, 1);
                }
                if (p.y > canvas.height) powerups.splice(i, 1);
            }
        }

        function playerHit() {
            lives--;
            updateUI();
            createParticles(player.x, player.y, '#4FC1E9', 20);
            SoundManager.playExplosion();
            if (lives <= 0) {
                gameOver();
            } else {
                // Downgrade weapon on hit? Maybe keep it fun and don't downgrade too hard
                // Reset to B1?
                player.weaponType = 'normal';
                player.bulletCount = 1;
            }
        }

        function createParticles(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 1.0, color: color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.05;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawStars() {
            ctx.fillStyle = '#FFF';
            stars.forEach(star => {
                ctx.globalAlpha = Math.random() * 0.5 + 0.5;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x, player.y - 20);
            ctx.lineTo(player.x - 20, player.y + 20);
            ctx.lineTo(player.x, player.y + 10);
            ctx.lineTo(player.x + 20, player.y + 20);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = `rgba(255, 100, 0, ${Math.random()})`;
            ctx.beginPath();
            ctx.moveTo(player.x - 10, player.y + 15);
            ctx.lineTo(player.x, player.y + 35);
            ctx.lineTo(player.x + 10, player.y + 15);
            ctx.fill();
        }

        function drawSummon() {
            if (!player.summon.active || !player.summon.bossData) return;

            let s = player.summon;
            let size = s.bossData.size / 3; // Smaller size (1/3)

            ctx.fillStyle = s.bossData.color;
            ctx.beginPath();
            ctx.arc(s.x, s.y, size / 2, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            drawGooglyEye(s.x - 3, s.y - 3, 3);
            drawGooglyEye(s.x + 3, s.y - 3, 3);
        }

        function drawBullets() {
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                if (b.type === 'laser') {
                    ctx.fillRect(b.x - b.width / 2, b.y, b.width, b.height);
                } else if (b.type === 'tracking') {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillRect(b.x - 2, b.y - 5, 4, 10);
                }
            });
        }

        function drawEnemies() {
            enemies.forEach(e => {
                ctx.fillStyle = e.color;

                if (e.isBoss) {
                    ctx.beginPath();
                    ctx.arc(e.x, e.y, e.size / 2, 0, Math.PI * 2);
                    ctx.fill();

                    drawGooglyEye(e.x - 15, e.y - 10, 10);
                    drawGooglyEye(e.x + 15, e.y - 10, 10);

                    ctx.fillStyle = 'red';
                    ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2 - 20, e.size, 5);
                    ctx.fillStyle = '#0f0';
                    ctx.fillRect(e.x - e.size / 2, e.y - e.size / 2 - 20, e.size * (e.hp / e.maxHp), 5);

                    if (e.pattern === 'shield' && e.shieldEntities) {
                        e.shieldEntities.forEach(s => {
                            ctx.fillStyle = '#00FFFF';
                            ctx.beginPath();
                            ctx.arc(s.x, s.y, 10, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                            ctx.beginPath();
                            ctx.moveTo(e.x, e.y);
                            ctx.lineTo(s.x, s.y);
                            ctx.stroke();
                        });
                    }

                } else {
                    ctx.beginPath();
                    let wobble = Math.sin(frameCount * 0.2 + e.wobbleOffset) * 2;

                    for (let i = 0; i < Math.PI * 2; i += 0.5) {
                        let r = e.size / 2 + Math.sin(frameCount * 0.5 + i * 5) * 3;
                        let x = e.x + Math.cos(i) * r;
                        let y = e.y + Math.sin(i) * r;
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.fill();

                    drawGooglyEye(e.x, e.y, e.size / 4);
                }
            });
        }

        function drawGooglyEye(x, y, size) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();

            let dx = player.x - x;
            let dy = player.y - y;
            let angle = Math.atan2(dy, dx);
            let pupilDist = size * 0.4;

            ctx.fillStyle = 'black';
            ctx.beginPath();
            ctx.arc(x + Math.cos(angle) * pupilDist, y + Math.sin(angle) * pupilDist, size / 2.5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawEnemyBullets() {
            enemyBullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function drawBossHealth() { }

        function drawPowerups() {
            powerups.forEach(p => {
                ctx.fillStyle = '#FFCE54';
                ctx.beginPath();
                ctx.arc(p.x, p.y, 15, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(p.type, p.x, p.y);
            });
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;
        }

        function updateUI() {
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            waveEl.textContent = wave;
        }

        function gameOver() {
            isGameOver = true;
            finalScoreEl.textContent = score;
            if (score > highScore) {
                gameOverTitle.textContent = "NEW HIGH SCORE!";
                gameOverTitle.style.color = "#FFCE54";
                nameInput.style.display = 'block';
                nameInput.focus();
            } else {
                gameOverTitle.textContent = "MISSION FAILED";
                gameOverTitle.style.color = "#ED5565";
                nameInput.style.display = 'none';
            }
            gameOverModal.style.display = 'block';
            focusFirstButton(gameOverModal);
        }

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
        });
        canvas.addEventListener('mousedown', () => isAutoShooting = !isAutoShooting);
        canvas.addEventListener('mouseup', () => isMouseDown = false);
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            mouseX = touch.clientX - rect.left;
        }, { passive: false });
        const fireBtn = document.getElementById('fireBtn');
        fireBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isMouseDown = true;
        }, { passive: false });
        fireBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            isMouseDown = false;
        }, { passive: false });

        // Keyboard Controls
        window.addEventListener('keydown', e => {
            const key = e.key;
            const keyCode = e.keyCode;

            // TV Keys
            const TV_ENTER = 13;
            const ALT_ENTER = 23;
            const ALT_BACK = 4;
            const TIZEN_BACK = 10009;

            // Movement keys are handled in updatePlayer
            keys[key] = true;
            keys[keyCode] = true; // Store keyCode as well for TV keys

            // If any directional key is pressed, disable mouse smoothing follow mode
            if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown', '4', '6', '8', '2', '21', '22', '19', '20'].includes(key) ||
                [37, 39, 38, 40, 21, 22, 19, 20].includes(keyCode)) {
                mouseX = player.x; // disable interpolation
            }

            let handled = false;

            // Handle Back Button
            if (key === 'Backspace' || key === 'Escape' || keyCode === 8 || keyCode === 27 || keyCode === 461 || keyCode === TIZEN_BACK || keyCode === ALT_BACK) {
                window.location.href = 'index.html';
                handled = true;
            }

            if (key === '5' || key === 'Enter' || key === ' ' || keyCode === TV_ENTER || keyCode === ALT_ENTER) {
                if (startScreen.style.display !== 'none') {
                    startGame();
                } else if (gameOverModal.style.display !== 'none') {
                    handleGameOverAction();
                } else {
                    isAutoShooting = !isAutoShooting;
                }
                handled = true;
            }

            if (key === '0') {
                toggleFullScreen();
                handled = true;
            }

            if (key.toLowerCase() === 'f') {
                toggleFullScreen();
                handled = true;
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, { passive: false });

        window.addEventListener('keyup', e => {
            keys[e.key] = false;
            keys[e.keyCode] = false;
        });

        // Check URL params for mode
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');

        function isTouchDevice() {
            return (('ontouchstart' in window) ||
                (navigator.maxTouchPoints > 0) ||
                (navigator.msMaxTouchPoints > 0));
        }

        if (mode === 'mobile' || isTouchDevice()) {
            document.body.classList.add('mode-mobile');
        } else if (mode === 'tv') {
            document.body.classList.add('mode-tv');
        }

        // Focus game container on load for TV
        window.onload = () => {
            document.getElementById('gameContainer').focus();
        };

        // Keep focus on game container
        document.getElementById('gameContainer').addEventListener("blur", () => {
            setTimeout(() => document.getElementById('gameContainer').focus(), 50);
        });

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }
    </script>
    <script src="global.js"></script>
</body>

</html>