<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1280, initial-scale=1">
    <title>Tower Stack | Man Games</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600;700&family=Nunito:wght@400;600;700;800&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --bg-color: #2c3e50;
            --text-color: #ecf0f1;
            --accent: #e67e22;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        h1 {
            font-family: 'Fredoka', sans-serif;
            position: absolute;
            top: 20px;
            font-size: 3rem;
            color: var(--accent);
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }

        canvas {
            background: linear-gradient(to bottom, #34495e, #2c3e50);
            border: 4px solid #fff;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            max-width: 100%;
            max-height: 80vh;
            outline: none;
            /* Remove focus outline */
        }

        .score-display {
            position: absolute;
            top: 100px;
            font-family: 'Fredoka', sans-serif;
            font-size: 4rem;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
            pointer-events: none;
        }

        .controls-hint {
            margin-top: 10px;
            font-size: 1rem;
            opacity: 0.8;
        }

        .back-btn {
            position: absolute;
            bottom: 20px;
            color: white;
            text-decoration: none;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            transition: all 0.2s;
        }

        .back-btn:hover,
        .back-btn:focus {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.05);
            outline: 2px solid var(--accent);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(3px);
        }

        .modal {
            background: white;
            padding: 40px;
            border-radius: 30px;
            text-align: center;
            border: 5px solid var(--accent);
            color: #2c3e50;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .modal h2 {
            font-family: 'Fredoka', sans-serif;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .modal p {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        button {
            padding: 15px 30px;
            border-radius: 15px;
            border: none;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: transform 0.2s;
            background: var(--accent);
            color: white;
            font-weight: bold;
            box-shadow: 0 5px 0 #d35400;
        }

        button:hover,
        button:focus {
            transform: translateY(-2px);
            box-shadow: 0 7px 0 #d35400;
            outline: 3px solid #2c3e50;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 3px 0 #d35400;
        }

        @keyframes popIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* TV Mode */
        body.mode-tv {
            cursor: none;
        }
    </style>
</head>

<body>

    <h1>Tower Stack</h1>
    <div class="score-display" id="scoreDisplay">0</div>

    <canvas id="gameCanvas" width="400" height="600" tabindex="0"></canvas>

    <div class="controls-hint">Press 5, Space, or Tap to Place Block</div>
    <a href="index.html" class="back-btn">← Back to Menu</a>

    <div class="modal-overlay" id="startModal">
        <div class="modal">
            <h2>Ready to Stack?</h2>
            <button onclick="startGame()">Start Game</button>
        </div>
    </div>

    <div class="modal-overlay" id="gameOverModal" style="display: none;">
        <div class="modal">
            <h2>Game Over</h2>
            <p>Height: <span id="finalScore">0</span></p>
            <button onclick="resetGame()">Play Again</button>
        </div>
    </div>

    <script>
        // Check URL params for mode
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode');
        if (mode) {
            document.body.classList.add('mode-' + mode);
            if (mode === 'tv') {
                document.querySelector(".controls-hint").innerText = "Press OK to Place Block";
            }
        }

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const startModal = document.getElementById('startModal');
        const gameOverModal = document.getElementById('gameOverModal');
        const finalScoreSpan = document.getElementById('finalScore');

        // Game Constants
        const BLOCK_HEIGHT = 30;
        const INITIAL_WIDTH = 200;
        const INITIAL_SPEED = 3;

        // Game State
        let blocks = [];
        let currentBlock = null;
        let score = 0;
        let speed = INITIAL_SPEED;
        let direction = 1; // 1 for right, -1 for left
        let gameState = 'start'; // start, playing, gameover
        let animationId;
        let cameraY = 0;

        // Colors
        const COLORS = ['#e74c3c', '#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6'];

        // Sound Manager
        const SoundManager = {
            ctx: null,
            init: function () {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
            },
            playTone: function (freq, type, duration, vol = 0.1) {
                if (!this.ctx) this.init();
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            place: function (perfect) {
                if (perfect) {
                    this.playTone(600, 'sine', 0.1, 0.2);
                    setTimeout(() => this.playTone(800, 'sine', 0.2, 0.2), 50);
                } else {
                    this.playTone(400, 'sine', 0.1, 0.1);
                }
            },
            gameOver: function () {
                this.playTone(200, 'sawtooth', 0.4, 0.2);
                setTimeout(() => this.playTone(150, 'sawtooth', 0.4, 0.2), 200);
            }
        };

        function startGame() {
            SoundManager.init();
            gameState = 'playing';
            startModal.style.display = 'none';
            gameOverModal.style.display = 'none';
            resetVars();
            spawnBlock();
            canvas.focus();
            loop();
        }

        function resetGame() {
            startGame();
        }

        function resetVars() {
            blocks = [];
            // Base block
            blocks.push({
                x: (canvas.width - INITIAL_WIDTH) / 2,
                y: canvas.height - 50,
                width: INITIAL_WIDTH,
                height: BLOCK_HEIGHT,
                color: COLORS[0]
            });
            score = 0;
            speed = INITIAL_SPEED;
            scoreDisplay.textContent = '0';
            cameraY = 0;
        }

        function spawnBlock() {
            const prevBlock = blocks[blocks.length - 1];
            const y = prevBlock.y - BLOCK_HEIGHT;

            currentBlock = {
                x: 0,
                y: y,
                width: prevBlock.width,
                height: BLOCK_HEIGHT,
                color: COLORS[blocks.length % COLORS.length]
            };

            // Random start side
            direction = Math.random() > 0.5 ? 1 : -1;
            if (direction === 1) currentBlock.x = -currentBlock.width;
            else currentBlock.x = canvas.width;
        }

        function placeBlock() {
            if (gameState !== 'playing') return;

            const prevBlock = blocks[blocks.length - 1];
            let width = currentBlock.width;
            let x = currentBlock.x;

            // Calculate overlap
            const overlapX = Math.max(x, prevBlock.x);
            const overlapRight = Math.min(x + width, prevBlock.x + prevBlock.width);
            const overlapWidth = overlapRight - overlapX;

            if (overlapWidth <= 0) {
                gameOver();
                return;
            }

            // Perfect placement tolerance
            const tolerance = 3;
            let perfect = false;
            if (Math.abs(x - prevBlock.x) < tolerance) {
                x = prevBlock.x;
                width = prevBlock.width; // Restore full width if perfect
                perfect = true;
            } else {
                width = overlapWidth;
                x = overlapX;
            }

            // Add placed block
            blocks.push({
                x: x,
                y: currentBlock.y,
                width: width,
                height: BLOCK_HEIGHT,
                color: currentBlock.color
            });

            SoundManager.place(perfect);
            if (navigator.vibrate) navigator.vibrate(40);
            score++;
            scoreDisplay.textContent = score;

            // Increase speed slightly
            speed += 0.1;

            spawnBlock();
        }

        function update() {
            if (currentBlock) {
                currentBlock.x += speed * direction;

                // Bounce off walls (or wrap? standard is bounce/pass)
                // Actually standard stacker is pass through and miss = lose part
                // But simplified version: bounce or just reset loop?
                // Let's do simple ping-pong
                // Bounce off walls
                if (currentBlock.x + currentBlock.width > canvas.width) {
                    direction = -1;
                }
                if (currentBlock.x < 0) {
                    direction = 1;
                }
            }

            // Camera follow
            const targetY = blocks[blocks.length - 1].y;
            if (targetY < canvas.height / 2) {
                cameraY += (canvas.height / 2 - targetY - cameraY) * 0.1;
            }
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(0, cameraY);

            // Draw placed blocks
            blocks.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.fillRect(b.x, b.y, b.width, b.height);
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.strokeRect(b.x, b.y, b.width, b.height);

                // Shine effect
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(b.x, b.y, b.width, b.height / 2);
            });

            // Draw moving block
            if (currentBlock) {
                ctx.fillStyle = currentBlock.color;
                ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.height);
                ctx.fillStyle = 'rgba(255,255,255,0.1)';
                ctx.fillRect(currentBlock.x, currentBlock.y, currentBlock.width, currentBlock.height / 2);
            }

            ctx.restore();
        }

        function loop() {
            if (gameState === 'playing') {
                update();
                draw();
                animationId = requestAnimationFrame(loop);
            }
        }

        function gameOver() {
            gameState = 'gameover';
            SoundManager.gameOver();
            cancelAnimationFrame(animationId);
            finalScoreSpan.textContent = score;
            gameOverModal.style.display = 'flex';

            setTimeout(() => {
                const btn = gameOverModal.querySelector('button');
                if (btn) btn.focus();
            }, 100);
        }

        // Input Handling
        document.addEventListener('keydown', (e) => {
            const key = e.key;
            const keyCode = e.keyCode;

            // TV Remote Keycodes
            const TV_ENTER = 13;
            const TV_OK = 13;
            const TV_BACK = 4;

            // Alternate TV Keys
            const ALT_ENTER = 23;
            const ALT_BACK = 4;
            const TIZEN_BACK = 10009;

            let handled = false;

            // Handle Back Button
            if (key === 'Backspace' || key === 'Escape' || keyCode === 8 || keyCode === 27 || keyCode === 461 || keyCode === TIZEN_BACK || keyCode === ALT_BACK) {
                window.location.href = 'index.html';
                handled = true;
            }

            if (['5', ' ', 'Enter'].includes(key) || keyCode === TV_ENTER || keyCode === ALT_ENTER) {
                if (gameState === 'playing') {
                    placeBlock();
                } else {
                    const focusedBtn = document.activeElement;
                    if (focusedBtn && focusedBtn.tagName === 'BUTTON') {
                        focusedBtn.click();
                    } else {
                        if (gameState === 'start') startGame();
                        else if (gameState === 'gameover') resetGame();
                    }
                }
                handled = true;
            }

            if (key === "0" || key.toLowerCase() === "f") {
                toggleFullscreen();
                handled = true;
            }

            if (handled) {
                e.preventDefault();
                e.stopPropagation();
            }
        });

        // Touch/Click Handling
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (gameState === 'playing') placeBlock();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === 'playing') placeBlock();
        }, { passive: false });

        // Initial Draw
        resetVars();
        draw();

        // Focus Start Button on load
        window.onload = () => {
            if (startModal.style.display !== 'none') {
                const btn = startModal.querySelector('button');
                if (btn) btn.focus();
            } else {
                canvas.focus();
            }
        };

        // Keep focus
        canvas.addEventListener('blur', () => {
            if (gameState === 'playing') {
                setTimeout(() => {
                    if (!document.activeElement || document.activeElement === document.body) {
                        canvas.focus();
                    }
                }, 200);
            }
        });

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

    </script>
    <script src="global.js"></script>
</body>

</html>
